"""
Memory Optimizer - Smart memory management
"""

import gc
import sys
import psutil
import threading
import time
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import weakref


@dataclass
class MemoryStats:
    """Memory statistics"""
    total_mb: float
    used_mb: float
    available_mb: float
    percent_used: float
    python_objects: int
    gc_collections: Dict[int, int]


class MemoryPool:
    """Object pool manager"""
    
    def __init__(self):
        self.pools: Dict[str, List[Any]] = {}
        self.max_pool_sizes: Dict[str, int] = {}
        self.created_count: Dict[str, int] = {}
        self.reused_count: Dict[str, int] = {}
    
    def register_pool(self, object_type: str, max_size: int = 100):
        """Register object pool"""
        self.pools[object_type] = []
        self.max_pool_sizes[object_type] = max_size
        self.created_count[object_type] = 0
        self.reused_count[object_type] = 0
    
    def get_object(self, object_type: str, factory_func=None):
        """Get object from pool"""
        if object_type not in self.pools:
            self.register_pool(object_type)
        
        pool = self.pools[object_type]
        
        if pool:
            # Reuse object from pool
            obj = pool.pop()
            self.reused_count[object_type] += 1
            return obj
        else:
            # Create new object
            if factory_func:
                obj = factory_func()
                self.created_count[object_type] += 1
                return obj
            return None
    
    def return_object(self, object_type: str, obj):
        """Return object to pool"""
        if object_type not in self.pools:
            return
        
        pool = self.pools[object_type]
        max_size = self.max_pool_sizes[object_type]
        
        if len(pool) < max_size:
            # Clean up object state (if cleanup method exists)
            if hasattr(obj, 'cleanup'):
                obj.cleanup()
            pool.append(obj)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get pool statistics"""
        stats = {}
        for obj_type in self.pools:
            total_created = self.created_count.get(obj_type, 0)
            total_reused = self.reused_count.get(obj_type, 0)
            reuse_rate = total_reused / (total_created + total_reused) if (total_created + total_reused) > 0 else 0
            
            stats[obj_type] = {
                "pool_size": len(self.pools[obj_type]),
                "max_size": self.max_pool_sizes[obj_type],
                "created": total_created,
                "reused": total_reused,
                "reuse_rate": round(reuse_rate, 3)
            }
        return stats


class WeakReferenceManager:
    """Âº±ÂºïÁî®ÁÆ°ÁêÜÂô®"""
    
    def __init__(self):
        self.references: Dict[str, weakref.WeakSet] = {}
        self.cleanup_callbacks: Dict[str, List] = {}
    
    def register_object(self, category: str, obj):
        """Ê≥®ÂÜåÂØπË±°Âº±ÂºïÁî®"""
        if category not in self.references:
            self.references[category] = weakref.WeakSet()
            self.cleanup_callbacks[category] = []
        
        self.references[category].add(obj)
    
    def add_cleanup_callback(self, category: str, callback):
        """Ê∑ªÂä†Ê∏ÖÁêÜÂõûË∞É"""
        if category not in self.cleanup_callbacks:
            self.cleanup_callbacks[category] = []
        self.cleanup_callbacks[category].append(callback)
    
    def cleanup_category(self, category: str):
        """Ê∏ÖÁêÜÊåáÂÆöÁ±ªÂà´ÁöÑÂØπË±°"""
        if category in self.references:
            # ÊâßË°åÊ∏ÖÁêÜÂõûË∞É
            for callback in self.cleanup_callbacks.get(category, []):
                try:
                    callback()
                except Exception as e:
                    print(f"Cleanup callback error: {e}")
            
            # Ê∏ÖÁ©∫Âº±ÂºïÁî®ÈõÜÂêà
            self.references[category].clear()
    
    def get_alive_count(self, category: str) -> int:
        """Ëé∑ÂèñÂ≠òÊ¥ªÂØπË±°Êï∞Èáè"""
        if category in self.references:
            return len(self.references[category])
        return 0


class MemoryOptimizer:
    """ÂÜÖÂ≠ò‰ºòÂåñÂô®‰∏ªÁ±ª"""
    
    def __init__(self):
        self.memory_pool = MemoryPool()
        self.weak_ref_manager = WeakReferenceManager()
        self.monitoring_active = False
        self.monitoring_thread = None
        self.memory_history: List[MemoryStats] = []
        
        # ÂÜÖÂ≠òÈòàÂÄº
        self.warning_threshold_percent = 75.0
        self.critical_threshold_percent = 85.0
        self.cleanup_threshold_percent = 80.0
        
        # ‰ºòÂåñÁªüËÆ°
        self.cleanup_count = 0
        self.gc_forced_count = 0
        self.pool_hits = 0
        
        # Ê≥®ÂÜåÂ∏∏Áî®ÂØπË±°Ê±†
        self._register_common_pools()
    
    def _register_common_pools(self):
        """Ê≥®ÂÜåÂ∏∏Áî®ÂØπË±°Ê±†"""
        self.memory_pool.register_pool("agent_response", max_size=50)
        self.memory_pool.register_pool("memory_object", max_size=100)
        self.memory_pool.register_pool("dialogue_context", max_size=30)
        self.memory_pool.register_pool("location_object", max_size=20)
    
    def start_monitoring(self, interval_seconds: int = 10):
        """ÂºÄÂßãÂÜÖÂ≠òÁõëÊéß"""
        self.monitoring_active = True
        
        def _monitor():
            while self.monitoring_active:
                try:
                    stats = self._collect_memory_stats()
                    self.memory_history.append(stats)
                    
                    # ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÂú®ÂêàÁêÜÂ§ßÂ∞è
                    if len(self.memory_history) > 500:
                        self.memory_history = self.memory_history[-250:]
                    
                    # Ê£ÄÊü•ÂÜÖÂ≠òÂéãÂäõÂπ∂‰ºòÂåñ
                    self._check_memory_pressure(stats)
                    
                    time.sleep(interval_seconds)
                except Exception as e:
                    print(f"Memory monitoring error: {e}")
                    time.sleep(interval_seconds)
        
        if self.monitoring_thread is None or not self.monitoring_thread.is_alive():
            self.monitoring_thread = threading.Thread(target=_monitor, daemon=True)
            self.monitoring_thread.start()
            print("‚úì Memory monitoring started")
    
    def stop_monitoring(self):
        """ÂÅúÊ≠¢ÂÜÖÂ≠òÁõëÊéß"""
        self.monitoring_active = False
        print("‚úì Memory monitoring stopped")
    
    def _collect_memory_stats(self) -> MemoryStats:
        """Êî∂ÈõÜÂÜÖÂ≠òÁªüËÆ°‰ø°ÊÅØ"""
        # Á≥ªÁªüÂÜÖÂ≠ò‰ø°ÊÅØ
        memory = psutil.virtual_memory()
        
        # PythonÂØπË±°ËÆ°Êï∞
        object_count = len(gc.get_objects())
        
        # GCÁªüËÆ°
        gc_stats = {}
        for i in range(3):
            gc_stats[i] = gc.get_count()[i]
        
        return MemoryStats(
            total_mb=memory.total / 1024 / 1024,
            used_mb=memory.used / 1024 / 1024,
            available_mb=memory.available / 1024 / 1024,
            percent_used=memory.percent,
            python_objects=object_count,
            gc_collections=gc_stats
        )
    
    def _check_memory_pressure(self, stats: MemoryStats):
        """Ê£ÄÊü•ÂÜÖÂ≠òÂéãÂäõÂπ∂ÈááÂèñ‰ºòÂåñÊé™ÊñΩ"""
        if stats.percent_used >= self.critical_threshold_percent:
            print(f"üö® Critical memory usage: {stats.percent_used:.1f}%")
            self.force_cleanup()
        elif stats.percent_used >= self.warning_threshold_percent:
            print(f"‚ö†Ô∏è High memory usage: {stats.percent_used:.1f}%")
            self.gentle_cleanup()
        elif stats.percent_used >= self.cleanup_threshold_percent:
            self.optimize_memory()
    
    def gentle_cleanup(self):
        """Ê∏©ÂíåÁöÑÂÜÖÂ≠òÊ∏ÖÁêÜ"""
        # Ê∏ÖÁêÜ‰ª£ÁêÜÂØπË±°ÁºìÂ≠ò
        self.weak_ref_manager.cleanup_category("agent_cache")
        
        # Âº∫Âà∂ÂûÉÂúæÂõûÊî∂
        collected = gc.collect()
        
        print(f"üßπ Gentle cleanup: {collected} objects collected")
        self.cleanup_count += 1
    
    def force_cleanup(self):
        """Âº∫Âà∂ÂÜÖÂ≠òÊ∏ÖÁêÜ"""
        # Ê∏ÖÁêÜÊâÄÊúâÁºìÂ≠ò
        for category in list(self.weak_ref_manager.references.keys()):
            self.weak_ref_manager.cleanup_category(category)
        
        # Ê∏ÖÁ©∫ÂØπË±°Ê±†
        for pool in self.memory_pool.pools.values():
            pool.clear()
        
        # Âº∫Âà∂ÂûÉÂúæÂõûÊî∂Â§öÊ¨°
        for _ in range(3):
            gc.collect()
        
        self.gc_forced_count += 1
        print("üö® Force cleanup completed")
    
    def optimize_memory(self):
        """‰ºòÂåñÂÜÖÂ≠ò‰ΩøÁî®"""
        # Ê∏ÖÁêÜPythonÂØπË±°ÂºïÁî®Âæ™ÁéØ
        gc.collect()
        
        # Ê∏ÖÁêÜÂº±ÂºïÁî®‰∏≠ÁöÑÊ≠ªÂØπË±°
        for category in self.weak_ref_manager.references:
            # WeakSet‰ºöËá™Âä®Ê∏ÖÁêÜÊ≠ªÂØπË±°ÔºåËøôÈáåÂè™ÊòØËß¶ÂèëÊ∏ÖÁêÜ
            len(self.weak_ref_manager.references[category])
    
    def get_object_from_pool(self, object_type: str, factory_func=None):
        """‰ªéÂØπË±°Ê±†Ëé∑ÂèñÂØπË±°"""
        obj = self.memory_pool.get_object(object_type, factory_func)
        if obj is not None:
            self.pool_hits += 1
        return obj
    
    def return_object_to_pool(self, object_type: str, obj):
        """ÂΩíËøòÂØπË±°Âà∞Ê±†"""
        self.memory_pool.return_object(object_type, obj)
    
    def register_agent_object(self, obj):
        """Ê≥®ÂÜåÊô∫ËÉΩ‰ΩìÂØπË±°"""
        self.weak_ref_manager.register_object("agents", obj)
    
    def register_memory_object(self, obj):
        """Ê≥®ÂÜåËÆ∞ÂøÜÂØπË±°"""
        self.weak_ref_manager.register_object("memories", obj)
    
    def get_memory_report(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÂÜÖÂ≠òÊä•Âëä"""
        current_stats = self._collect_memory_stats()
        
        # ËÆ°ÁÆóÂÜÖÂ≠òË∂ãÂäø
        if len(self.memory_history) > 1:
            previous_stats = self.memory_history[-2]
            memory_trend = current_stats.used_mb - previous_stats.used_mb
        else:
            memory_trend = 0.0
        
        return {
            "timestamp": datetime.now().isoformat(),
            "current_memory": {
                "total_mb": round(current_stats.total_mb, 2),
                "used_mb": round(current_stats.used_mb, 2),
                "available_mb": round(current_stats.available_mb, 2),
                "percent_used": round(current_stats.percent_used, 2),
                "python_objects": current_stats.python_objects
            },
            "memory_trend_mb": round(memory_trend, 2),
            "optimization_stats": {
                "cleanup_count": self.cleanup_count,
                "gc_forced_count": self.gc_forced_count,
                "pool_hits": self.pool_hits
            },
            "object_pools": self.memory_pool.get_stats(),
            "weak_references": {
                category: self.weak_ref_manager.get_alive_count(category)
                for category in self.weak_ref_manager.references
            },
            "thresholds": {
                "warning_percent": self.warning_threshold_percent,
                "critical_percent": self.critical_threshold_percent,
                "cleanup_percent": self.cleanup_threshold_percent
            },
            "status": {
                "memory_ok": current_stats.percent_used < self.warning_threshold_percent,
                "trend_ok": memory_trend < 50.0  # Â¢ûÈïøÂ∞è‰∫é50MB
            }
        }


# ÂÖ®Â±ÄÂÜÖÂ≠ò‰ºòÂåñÂô®ÂÆû‰æã
_memory_optimizer = None

def get_memory_optimizer() -> MemoryOptimizer:
    """Ëé∑ÂèñÂÖ®Â±ÄÂÜÖÂ≠ò‰ºòÂåñÂô®ÂÆû‰æã"""
    global _memory_optimizer
    if _memory_optimizer is None:
        _memory_optimizer = MemoryOptimizer()
    return _memory_optimizer


def optimize_agent_memory(agent_class):
    """Ë£ÖÈ•∞Âô®Ôºö‰∏∫Êô∫ËÉΩ‰ΩìÁ±ªÊ∑ªÂä†ÂÜÖÂ≠ò‰ºòÂåñ"""
    class OptimizedAgent(agent_class):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            # Ê≥®ÂÜåÂà∞ÂÜÖÂ≠ò‰ºòÂåñÂô®
            get_memory_optimizer().register_agent_object(self)
        
        def __del__(self):
            # Ê∏ÖÁêÜËµÑÊ∫ê
            if hasattr(self, 'memory'):
                if hasattr(self.memory, 'clear'):
                    self.memory.clear()
    
    return OptimizedAgent


def memory_efficient(func):
    """Ë£ÖÈ•∞Âô®Ôºö‰ΩøÂáΩÊï∞Êõ¥È´òÊïàÂú∞‰ΩøÁî®ÂÜÖÂ≠ò"""
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        optimizer = get_memory_optimizer()
        
        # ÊâßË°åÂâçÊ£ÄÊü•ÂÜÖÂ≠ò
        stats_before = optimizer._collect_memory_stats()
        
        try:
            result = func(*args, **kwargs)
            return result
        finally:
            # ÊâßË°åÂêéÊ£ÄÊü•ÂÜÖÂ≠òÔºåÂ¶ÇÊûúÂ¢ûÈïøËøáÂ§öÂàôÊ∏ÖÁêÜ
            stats_after = optimizer._collect_memory_stats()
            memory_growth = stats_after.used_mb - stats_before.used_mb
            
            if memory_growth > 100:  # Â¢ûÈïøË∂ÖËøá100MB
                optimizer.gentle_cleanup()
    
    return wrapper


if __name__ == "__main__":
    # ÊµãËØïÂÜÖÂ≠ò‰ºòÂåñÂô®
    optimizer = MemoryOptimizer()
    optimizer.start_monitoring(interval_seconds=2)
    
    # Ê®°ÊãüÂÜÖÂ≠ò‰ΩøÁî®
    data = []
    for i in range(1000):
        data.append([0] * 1000)
        time.sleep(0.01)
    
    # Ëé∑ÂèñÊä•Âëä
    report = optimizer.get_memory_report()
    print("Memory Report:")
    import json
    print(json.dumps(report, indent=2, ensure_ascii=False))
    
    # Ê∏ÖÁêÜ
    del data
    optimizer.force_cleanup()
    
    time.sleep(2)
    optimizer.stop_monitoring()